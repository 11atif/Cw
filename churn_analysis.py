# -*- coding: utf-8 -*-
"""Churn Analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1toKA4KSu2WlxG000QJLQThZtl79owP1j

# LLP132
# Principles of Artificial Intelligence and Data Analystics

### Data Preprocessing
"""

import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('internet_service_churn.csv', encoding = 'utf-8')
df.head()

print(df.shape)

# Summary statistics for numerical columns
summary_stats = df.describe()

# Display summary statistics
print("Summary Statistics:")
print(summary_stats)

# Display a sample of the DataFrame
sample_data = df.sample(5)  # Adjust the number as needed
print("Sample Data:")
print(sample_data)

df.describe()

column_names = df.columns.tolist()
column_names

#Check the duplication in the dataset
df[df.duplicated(keep=False)]

#Check for the NaN value in the dataset
print(df.isnull().sum())

#Fill the NaN value in the remaining contract as 0.
df['reamining_contract'].fillna(0, inplace=True)

#Check for the NaN value in the dataset
print(df.isnull().sum())

df.dropna(axis=0, inplace=True)

#Check for the NaN value in the dataset
print(df.isnull().sum())

print(df.shape)

df.to_csv('Final_dataset.csv', index = False)





"""### EDA"""

# Different Groups

count_tv = df[df['is_tv_subscriber'] == 1].shape[0]

count_movie = df[df['is_movie_package_subscriber'] == 1].shape[0]

count_both = df[(df['is_tv_subscriber'] == 1) & (df['is_movie_package_subscriber'] == 1)].shape[0]

count_none = df[(df['is_tv_subscriber'] == 0) & (df['is_movie_package_subscriber'] == 0)].shape[0]

print(f"Number of Customers with TV Subscriptions: {count_tv}")
print(f"Number of Customers with Movie Subscriptions: {count_movie}")
print(f"Number of Customers with Both TV and Movie Subscriptions: {count_both}")
print(f"Number of Customers with None (Neither TV nor Movie Subscription): {count_none}")

# Convert to Percentage
total_customers = df.shape[0]
percent_tv = (count_tv / total_customers) * 100
percent_movie = (count_movie / total_customers) * 100
percent_both = (count_both / total_customers) * 100
percent_none = (count_none / total_customers) * 100

print(f"Percentage of Customers with TV Subscriptions: {percent_tv:.2f}%")
print(f"Percentage of Customers with Movie Subscriptions: {percent_movie:.2f}%")
print(f"Percentage of Customers with Both TV and Movie Subscriptions: {percent_both:.2f}%")
print(f"Percentage of Customers with None (Neither TV nor Movie Subscription): {percent_none:.2f}%")

# Box Plot Download Average
plt.figure(figsize=(12, 8))
sns.boxplot(x='churn', y='download_avg', data=df)
plt.title('Box Plot of Download Average by Churn')
plt.xlabel('Churn (1: Yes, 0: No)')
plt.ylabel('Download Average')
plt.show()

# Box Plot Bill Average

plt.figure(figsize=(12, 8))
sns.boxplot(x='churn', y='bill_avg', data=df)
plt.title('Box Plot of Bill Average by Churn')
plt.xlabel('Churn (1: Yes, 0: No)')
plt.ylabel('Bill Average')
plt.show()

# 99 Percentile of Data

percentage = 99

download_percentile = np.percentile(df['download_avg'], percentage)
print(f'{percentage}% of the data in Download Average falls below {download_percentile}')

bill_percentile = np.percentile(df['bill_avg'], percentage)
print(f'{percentage}% of the data in Bill Average falls below {bill_percentile}')

# Download Average for churn

download_lower_limit = 1
download_upper_limit = 238

filtered_df = df[(df['download_avg'] >= download_lower_limit) & (df['download_avg'] <= download_upper_limit)]

plt.figure(figsize=(12, 8))
sns.boxplot(x='churn', y='download_avg', data=filtered_df)
plt.title('Box Plot of Download Average by Churn (Download Limit: 1-238)')
plt.xlabel('Churn (1: Yes, 0: No)')
plt.ylabel('Download Average')
plt.show()

# Mean Download Average for Churn

download_lower_limit = 1
download_upper_limit = 238

filtered_df_churn_1 = df[(df['churn'] == 1) & (df['download_avg'] >= download_lower_limit) & (df['download_avg'] <= download_upper_limit)]
filtered_df_churn_0 = df[(df['churn'] == 0) & (df['download_avg'] >= download_lower_limit) & (df['download_avg'] <= download_upper_limit)]

mean_download_churn_1 = filtered_df_churn_1['download_avg'].mean()
mean_download_churn_0 = filtered_df_churn_0['download_avg'].mean()

plt.figure(figsize=(8, 6))
sns.barplot(x=['Churn 1', 'Churn 0'], y=[mean_download_churn_1, mean_download_churn_0])
plt.title(f'Mean Download Average for Churn 1 and Churn 0 (Download Limit: {download_lower_limit}-{download_upper_limit})')
plt.xlabel('Churn Status')
plt.ylabel('Mean Download Average')
plt.show()

# Box Plot Bill Average Churn

bill_lower_limit = 1
bill_upper_limit = 60

filtered_df = df[(df['bill_avg'] >= bill_lower_limit) & (df['bill_avg'] <= bill_upper_limit)]

plt.figure(figsize=(12, 8))
sns.boxplot(x='churn', y='bill_avg', data=filtered_df)
plt.title('Box Plot of Bill Average by Churn (Bill Limit: 1-60)')
plt.xlabel('Churn (1: Yes, 0: No)')
plt.ylabel('Bill Average')
plt.show()

# Mean Bill Average Churn

bill_lower_limit = 1
bill_upper_limit = 60


filtered_df_churn_1 = df[(df['churn'] == 1) & (df['bill_avg'] >= bill_lower_limit) & (df['bill_avg'] <= bill_upper_limit)]
filtered_df_churn_0 = df[(df['churn'] == 0) & (df['bill_avg'] >= bill_lower_limit) & (df['bill_avg'] <= bill_upper_limit)]


mean_bill_churn_1 = filtered_df_churn_1['bill_avg'].mean()
mean_bill_churn_0 = filtered_df_churn_0['bill_avg'].mean()


plt.figure(figsize=(8, 6))
sns.barplot(x=['Churn 1', 'Churn 0'], y=[mean_bill_churn_1, mean_bill_churn_0])
plt.title(f'Mean Bill for Churn 1 and Churn 0 (Bill Limit: {bill_lower_limit}-{bill_upper_limit})')
plt.xlabel('Churn Status')
plt.ylabel('Mean Bill')
plt.show()

# Service failure count for churn
total_failure_count_churned = df[df['churn'] == 1]['service_failure_count'].sum()
total_failure_count_non_churned = df[df['churn'] == 0]['service_failure_count'].sum()

print(f"Total Service Failure Count for Churned Customers: {total_failure_count_churned:}")
print(f"Total Service Failure Count for Non-Churned Customers: {total_failure_count_non_churned:}")

plt.figure(figsize=(8, 6))
sns.barplot(x=['Churned', 'Not Churned'], y=[total_failure_count_churned, total_failure_count_non_churned], palette='pastel')
plt.title('Total Service Failure Count for Customers')
plt.xlabel('Churn Status')
plt.ylabel('Total Service Failure Count')
plt.show()

# Limit the remaining contract to less than 1 month
remaining_contract_limit = 0.082

filtered_df = df[df['reamining_contract'] < remaining_contract_limit]

total_failure_count_churned = filtered_df[filtered_df['churn'] == 1]['service_failure_count'].sum()
total_failure_count_non_churned = filtered_df[filtered_df['churn'] == 0]['service_failure_count'].sum()

print(f"Total Service Failure Count for Customers with Remaining Contract < 0.082 and Churned: {total_failure_count_churned}")
print(f"Total Service Failure Count for Customers with Remaining Contract < 0.082 and Not Churned: {total_failure_count_non_churned}")

# Graph
plt.figure(figsize=(8, 6))
sns.barplot(x=['Churned', 'Not Churned'], y=[total_failure_count_churned, total_failure_count_non_churned], palette='pastel')
plt.title('Total Service Failure Count for Customers with Remaining Contract < 0.082')
plt.xlabel('Churn Status')
plt.ylabel('Total Service Failure Count')
plt.show()

# Mean Bill for TV Subscriber

bill_lower_limit = 1
bill_upper_limit = 60


filtered_df_tv_subscriber = df[(df['is_tv_subscriber'] == 1) & (df['bill_avg'] >= bill_lower_limit) & (df['bill_avg'] <= bill_upper_limit)]
filtered_df_non_tv_subscriber = df[(df['is_tv_subscriber'] == 0) & (df['bill_avg'] >= bill_lower_limit) & (df['bill_avg'] <= bill_upper_limit)]


mean_bill_tv_subscriber = filtered_df_tv_subscriber['bill_avg'].mean()
mean_bill_non_tv_subscriber = filtered_df_non_tv_subscriber['bill_avg'].mean()


plt.figure(figsize=(8, 6))
sns.barplot(x=['TV Subscriber', 'Non-TV Subscriber'], y=[mean_bill_tv_subscriber, mean_bill_non_tv_subscriber])
plt.title(f'Mean Bill for TV Subscribers and Non-Subscribers (Bill Limit: {bill_lower_limit}-{bill_upper_limit})')
plt.xlabel('Subscriber Type')
plt.ylabel('Mean Bill')
plt.show()

# Subscription Age for TV Customers

plt.figure(figsize=(10, 8))
sns.histplot(df, x='subscription_age', hue='is_tv_subscriber', bins=30, kde=True, palette='viridis')
plt.title('Comparison of Subscription Age for TV Subscribers and Non-Subscribers')
plt.xlabel('Subscription Age')
plt.ylabel('Frequency')
plt.show()

# Mean Bill for customer with remaining contract at least 1 month

reamining_contract_limit = 0.083
min_bill = 1

filtered_df_less = df[(df['reamining_contract'] <= reamining_contract_limit) & (df['bill_avg'] > min_bill)]
filtered_df_more = df[df['reamining_contract'] > reamining_contract_limit]


mean_bill_less = filtered_df_less['bill_avg'].mean()
mean_bill_more = filtered_df_more['bill_avg'].mean()


plt.figure(figsize=(8, 6))
sns.barplot(x=['Remaining Contracts <= 0.083 and Bill > 1', 'Remaining Contracts > 0.083'], y=[mean_bill_less, mean_bill_more])
plt.title(f'Mean Bill for Remaining Contracts (Bill > 1) - Comparison')
plt.xlabel('Remaining Contract Status')
plt.ylabel('Mean Bill')
plt.show()

"""## Part 2"""

import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer
import matplotlib.pyplot as plt
import seaborn as sns

df1 = pd.read_csv('Final_dataset.csv')

print(df1.shape)

df1

#Adding a new feature for determine whether the customer is on contract or not
df1['is_contracted'] = df1['reamining_contract'].apply(lambda x: 0 if x < 0.083 else 1)

df1.head()

df1 = df1[['id', 'is_tv_subscriber', 'is_movie_package_subscriber', 'subscription_age',
         'bill_avg', 'reamining_contract', 'is_contracted', 'service_failure_count',
         'download_avg', 'upload_avg', 'download_over_limit', 'churn']]

df1.head()

df1['short_term_contract'] = df1['reamining_contract'].apply(lambda x: 1 if x < 1.33 else 0)
df1['long_term_contract'] = df1['reamining_contract'].apply(lambda x: 1 if x >= 1.33 else 0)

df1.head()

df1.describe()

df1 = df1[['id', 'is_tv_subscriber', 'is_movie_package_subscriber', 'subscription_age',
         'bill_avg', 'reamining_contract', 'is_contracted', 'short_term_contract', 'long_term_contract', 'service_failure_count',
         'download_avg', 'upload_avg', 'download_over_limit', 'churn']]

df1.head()

short_term_contract_counts = df1['short_term_contract'].value_counts()
short_term_contract_counts

long_term_contract_counts = df1['long_term_contract'].value_counts()
long_term_contract_counts



import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn import tree
from sklearn.metrics import accuracy_score

from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import StandardScaler

percentage = 99

for column in df1.columns:
    if df1[column].dtype in [np.int64, np.float64]:
        column_percentile = np.percentile(df1[column], percentage)
        print(f'{percentage}% of the data in {column} falls below {column_percentile}')

# Assuming df1 is your DataFrame with internet provider data
# Specify the columns to exclude from features (e.g., customer ID, target variables)
exclude_columns = ['id', 'churn']

# Filter the dataset based on conditions
filtered_df = df1[
    (df1['subscription_age'] < 9) &
    (df1['bill_avg'].between(1, 60)) &
    (df1['reamining_contract'] != 0) &
    (df1['download_avg'].between(1, 238)) &
    (df1['upload_avg'].between(1, 36))
]

# Split the filtered data into training and testing sets
X_train, X_val, y_train, y_val = train_test_split(filtered_df.drop(exclude_columns, axis=1),
                                                  filtered_df['churn'], test_size=0.2, random_state=42)

# Initialize a Decision Tree classifier
model = DecisionTreeClassifier(random_state=42, max_depth=3, min_samples_split=5)

# Fit the model
model.fit(X_train, y_train)

# Create the figure
fig, ax = plt.subplots(figsize=(20, 10))
tree.plot_tree(model, ax=ax, feature_names=X_train.columns, class_names=['Not Churn', 'Churn'], filled=True)
plt.show()

# Make predictions on the validation set
y_pred = model.predict(X_val)


# Make predictions on the validation set
y_pred = model.predict(X_val)

# Calculate precision
precision = precision_score(y_val, y_pred)


# Calculate accuracy
accuracy = accuracy_score(y_val, y_pred)

# Print the results
print(f'Accuracy: {accuracy:.4f}')
print(f'Precision: {precision:.4f}')

# Select features and target variable
selected_features = ['is_tv_subscriber',
                     'is_movie_package_subscriber',
                     'subscription_age',
                     'bill_avg',
                     'reamining_contract',
                     'service_failure_count',
                     'download_avg', 'upload_avg',
                     'download_over_limit']

X = df1[selected_features]
y = df1['churn']


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

svm_model = SVC(kernel='linear', C=1.0)
svm_model.fit(X_train_scaled, y_train)

y_pred = svm_model.predict(X_test_scaled)

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

print(f'Accuracy: {accuracy}')
print(f'Precision: {precision}')
print(f'Recall: {recall}')
print(f'F1 Score: {f1}')

